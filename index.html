<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Trading Journal</title>
  <link rel="icon" type="image/png" href="favicon.png">

  <!-- Chart.js and PapaParse via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    /* Core color palette */
    :root {
      --bg: #0c0f15;
      --surface: #161c24;
      --card: #1f2933;
      --border: rgba(255,255,255,0.09);
      --text: #f8fafc;
      --muted: #94a3b8;
      --accent: #3b82f6;
      --accent-light: #60a5fa;
      --good: #16a34a;
      --bad: #dc2626;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, Arial, sans-serif;
      background: radial-gradient(circle at 0% 20%, rgba(96,165,250,0.12), transparent 60%),
                  radial-gradient(circle at 80% 0%, rgba(34,197,94,0.10), transparent 60%), var(--bg);
      color: var(--text);
      line-height: 1.4;
    }
    .container {
      max-width: 1180px;
      margin: 0 auto;
      padding: 2rem 1rem 4rem;
    }
    h1 {
      margin: 0;
      font-size: 2.5rem;
      font-weight: 700;
      text-align: center;
    }
    p.tagline {
      text-align: center;
      margin: 0.5rem auto 2rem;
      color: var(--muted);
      max-width: 600px;
    }
    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      align-items: center;
      margin-bottom: 1rem;
    }
    .file-input {
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      border: 2px dashed var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      cursor: pointer;
    }
    .btn {
      padding: 0.6rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .btn.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .btn.primary:hover { background: var(--accent-light); }
    .btn-group button {
      padding: 0.4rem 0.8rem;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--muted);
      border-radius: 0.4rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .btn-group button.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    /* KPI cards */
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.8rem;
      margin-top: 1.2rem;
      margin-bottom: 2rem;
    }
    .kpi-card {
      background: var(--card);
      padding: 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      box-shadow: 0 8px 16px rgba(0,0,0,0.25);
    }
    .kpi-card h3 {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
      letter-spacing: 0.02em;
    }
    .kpi-card .value {
      margin-top: 0.2rem;
      font-size: 1.75rem;
      font-weight: 700;
    }
    /* Charts */
    .chart-wrapper {
      background: var(--card);
      padding: 1.25rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      box-shadow: 0 8px 16px rgba(0,0,0,0.25);
      margin-bottom: 1.5rem;
    }
    /* Grid for charts container */
    .chart-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: 1fr;
    }
    @media (min-width: 900px) {
      .chart-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.6rem;
    }
    .chart-header h3 {
      margin: 0;
      font-size: 1rem;
      color: var(--muted);
    }

    /* Grid for analysis charts */
    .analysis-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .toggle-btns button {
      padding: 0.3rem 0.8rem;
      border: 1px solid var(--border);
      border-radius: 0.4rem;
      background: var(--surface);
      color: var(--muted);
      font-size: 0.8rem;
      margin-left: 0.2rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .toggle-btns button.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    /* Filter buttons */
    .range-filter {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      justify-content: center;
      margin: 1rem 0;
    }
    .range-filter button {
      padding: 0.4rem 0.8rem;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--muted);
      border-radius: 0.4rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .range-filter button.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    .custom-range {
      display: none;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .custom-range input[type="date"] {
      padding: 0.4rem 0.6rem;
      border: 1px solid var(--border);
      border-radius: 0.4rem;
      background: var(--surface);
      color: var(--text);
    }
    .custom-range button.apply {
      padding: 0.4rem 0.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--accent);
      background: var(--accent);
      color: white;
      cursor: pointer;
    }
    /* Search and table */
    .search-bar {
      margin: 1rem 0;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .search-bar input {
      flex: 1;
      padding: 0.5rem 0.8rem;
      border-radius: 0.4rem;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
    }
    .stats-display {
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    th {
      text-align: left;
      padding: 0.5rem 0.4rem;
      color: var(--muted);
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    td {
      padding: 0.45rem 0.4rem;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    tr:hover {
      background: rgba(255,255,255,0.03);
      cursor: pointer;
    }
    .pos { color: var(--good); font-weight: 600; }
    .neg { color: var(--bad); font-weight: 600; }
    /* Modal details */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.65);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    .modal-content {
      background: var(--card);
      border-radius: 0.8rem;
      border: 1px solid var(--border);
      padding: 1.5rem;
      max-width: 680px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0,0,0,0.35);
    }
    .modal-content h4 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1.2rem;
      color: var(--accent);
    }
    .modal-content .details {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.6rem;
    }
    .modal-content .details div {
      background: var(--surface);
      padding: 0.6rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
    }
    .modal-content .details div span {
      display: block;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .modal-content .details div strong {
      display: block;
      margin-top: 0.2rem;
      font-size: 0.9rem;
    }
    .modal-content .images {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }
    .modal-content .images img {
  max-width: 100%;
  width: 100%;
}
    .modal-close {
      margin-top: 1rem;
      text-align: right;
    }
    .modal-close button {
      padding: 0.4rem 0.8rem;
      background: var(--bad);
      border: none;
      color: white;
      border-radius: 0.4rem;
      cursor: pointer;
    }
#applyRangeBtn { display: none !important; }

/* ===== Trades table: no partir Fecha/Hora ===== */
td.col-date, th.col-date, .mono {
  white-space: nowrap;
}

td.col-date, th.col-date {
  min-width: 120px;
}

td, th { padding: 0.55rem 0.5rem; }

/* ===== Outcome colors ===== */
.outcome-win {
  color: #16a34a;
  font-weight: 700;
}

.outcome-loss {
  color: #dc2626;
  font-weight: 700;
}

.outcome-be {
  color: #facc15;
  font-weight: 700;
}
/* ===== Monospace para fechas, números y precios ===== */
.mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
               "Liberation Mono", "Courier New", monospace;
  white-space: nowrap;
}
/* ===== Forzar iconos de time/date en blanco ===== */

/* Chrome / Edge / Safari */
input[type="time"]::-webkit-calendar-picker-indicator,
input[type="date"]::-webkit-calendar-picker-indicator {
  filter: invert(1);
  opacity: 1;
  cursor: pointer;
}

/* Firefox (usa accent-color) */
input[type="time"],
input[type="date"] {
  accent-color: #ffffff;
}
/* ===== Multi-select dropdown (Confluencias) ===== */
.multi-select { position: relative; min-width: 260px; }

.multi-select-btn{
  width: 260px;
  padding: 0.45rem 0.6rem;
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  background: var(--surface);
  color: var(--text);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 0.6rem;
  cursor:pointer;
}

.multi-select-btn .chev{ color: var(--muted); font-size: 0.9rem; }

.multi-select-panel{
  position:absolute;
  top: calc(100% + 8px);
  left: 0;
  width: 100%;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 0.75rem;
  box-shadow: 0 20px 40px rgba(0,0,0,0.35);
  padding: 0.6rem;
  display:none;
  z-index: 50;
}

.multi-select.open .multi-select-panel{ display:block; }

.multi-select-search input{
  width: 100%;
  padding: 0.45rem 0.6rem;
  border-radius: 0.5rem;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
}

.multi-select-actions{
  display:flex;
  justify-content:space-between;
  margin-top: 0.45rem;
  margin-bottom: 0.45rem;
}

.multi-select-actions .link{
  background: transparent;
  border: none;
  color: var(--accent-light);
  cursor:pointer;
  font-weight: 600;
  padding: 0.2rem 0.2rem;
}

.multi-select-list{
  max-height: 220px;
  overflow:auto;
  border-top: 1px solid rgba(255,255,255,0.06);
  padding-top: 0.45rem;
}

.multi-select-item{
  display:flex;
  align-items:center;
  gap: 0.55rem;
  padding: 0.35rem 0.3rem;
  border-radius: 0.4rem;
  cursor:pointer;
}

.multi-select-item:hover{
  background: rgba(255,255,255,0.04);
}

.multi-select-item input{
  width: 16px;
  height: 16px;
  accent-color: var(--accent);
}
.multi-select-item span{
  color: var(--text);
  font-size: 0.85rem;
}
  </style>
</head>
<body>
  <div class="container">
    <h1>Trading Journal</h1>

    <!-- Display last update time for Google Sheet auto‑sync -->
    <div id="lastUpdated" style="color:var(--muted); font-size:0.8rem; text-align:center; margin-top:0.5rem;"></div>

    <!-- Capital input row -->
<!-- Hour filter -->
<div style="display:flex; justify-content:center; align-items:center; gap:0.5rem; margin-bottom:1rem; flex-wrap:wrap;">
  <label style="color:var(--muted); font-size:0.85rem;">Hora desde:</label>
  <input id="timeFrom" type="time" value="00:00"
    style="padding:0.4rem 0.6rem; border:1px solid var(--border); border-radius:0.4rem; background:var(--surface); color:var(--text); width:110px;">

  <label style="color:var(--muted); font-size:0.85rem;">Hora hasta:</label>
  <input id="timeTo" type="time" value="23:59"
    style="padding:0.4rem 0.6rem; border:1px solid var(--border); border-radius:0.4rem; background:var(--surface); color:var(--text); width:110px;">

<button id="resetFiltersBtn" class="btn">Limpiar filtros</button>
</div>
<!-- Day of week filter -->
<div style="display:flex; justify-content:center; align-items:center; gap:0.5rem; margin-bottom:1rem; flex-wrap:wrap;">
  <label style="color:var(--muted); font-size:0.85rem;">Día:</label>

  <select id="dayFilter"
    style="padding:0.45rem 0.6rem; border:1px solid var(--border); border-radius:0.5rem; background:var(--surface); color:var(--text); min-width:140px;">
    <option value="ALL">Todos</option>
    <option value="1">Lunes</option>
    <option value="2">Martes</option>
    <option value="3">Miércoles</option>
    <option value="4">Jueves</option>
    <option value="5">Viernes</option>
  </select>
</div>
    <!-- Range filter buttons -->
    <div class="range-filter">
      <button id="todayBtn">Hoy</button>
      <button id="weekBtn">Esta semana</button>
      <button id="monthBtn">Este mes</button>
      <button id="ytdBtn">YTD</button>
      <button id="customBtn">Rango</button>
    </div>
    <div class="custom-range" id="customRange">
      <input type="date" id="startDate">
      <input type="date" id="endDate">
      <button class="apply" id="applyRangeBtn">Aplicar</button>
    </div>
   <!-- Pair filter + Reset filters -->
<div style="display:flex; justify-content:center; align-items:center; gap:0.5rem; margin-bottom:1rem; flex-wrap:wrap;">
  <label for="pairFilter" style="color:var(--muted); font-size:0.85rem;">Par:</label>

  <select id="pairFilter"
    style="padding:0.45rem 0.6rem; border:1px solid var(--border); border-radius:0.5rem; background:var(--surface); color:var(--text); min-width:140px;">
    <option value="ALL">Todos</option>
  </select>

</div>
<div style="display:flex; justify-content:center; align-items:center; gap:0.5rem; margin-bottom:1rem; flex-wrap:wrap;">
  <label style="color:var(--muted); font-size:0.85rem;">Confluencias:</label>

  <div class="multi-select" id="confMulti">
    <button type="button" class="multi-select-btn" id="confBtn">
      <span id="confBtnLabel">Todas</span>
      <span class="chev">▾</span>
    </button>

    <div class="multi-select-panel" id="confPanel">
      <div class="multi-select-search">
        <input type="text" id="confSearch" placeholder="Buscar confluencia…">
      </div>

      <div class="multi-select-actions">
        <button type="button" class="link" id="confAll">Seleccionar todo</button>
        <button type="button" class="link" id="confNone">Limpiar</button>
      </div>

      <div class="multi-select-list" id="confList"></div>
    </div>
  </div>
</div>
    <!-- KPI cards -->
    <div class="kpi-grid">
        <!-- Return percentage for the selected period inserted before the PnL card -->
        <div class="kpi-card"><h3>Retorno (%)</h3><div class="value" id="kpiReturn">0.00%</div></div>
        <div class="kpi-card"><h3>PnL total</h3><div class="value" id="kpiTotal">0.00</div></div>
        <div class="kpi-card"><h3>Trades</h3><div class="value" id="kpiTrades">0</div></div>
      <div class="kpi-card"><h3>Win rate</h3><div class="value" id="kpiWin">0%</div></div>
      <div class="kpi-card"><h3>Max drawdown</h3><div class="value" id="kpiDD">0%</div></div>
      <div class="kpi-card"><h3>Sharpe</h3><div class="value" id="kpiSharpe">0.00</div></div>
      <div class="kpi-card"><h3>Calmar</h3><div class="value" id="kpiCalmar">0.00</div></div>

      <!-- Additional KPIs for more advanced metrics -->
      <div class="kpi-card"><h3>Expectancia</h3><div class="value" id="kpiExpectancy">0.00</div></div>

      <!-- KPI cards for Risk:Reward analysis -->
      <div class="kpi-card"><h3>RR real prom.</h3><div class="value" id="kpiRRReal">0.00R</div></div>
      <div class="kpi-card"><h3>RR potencial prom.</h3><div class="value" id="kpiRRPot">0.00R</div></div>
      <div class="kpi-card"><h3>Pips potencial prom.</h3><div class="value" id="kpiPipsPotProm">0</div></div>
      
    <!-- New KPI card showing the optimal take‑profit level computed from the MFE P80 statistic. -->
    <div class="kpi-card">
  <h3>TP Óptimo (máx. expectancia)</h3>
  <div class="value" id="kpiTPOptimo">0</div>
</div>
<div class="kpi-card">
  <h3>TP Óptimo (con parciales)</h3>
  <div class="value" id="kpiTPOptimoParcial">0</div>
</div>
<div class="kpi-card">
  <h3>TP Óptimo (parciales) en pips</h3>
  <div class="value" id="kpiTPOptimoParcialPips">0</div>
</div>
</div>
    <!-- Charts container: equity and PnL side by side -->
    <div class="chart-grid">
      <!-- Equity chart -->
      <div class="chart-wrapper">
        <div class="chart-header">
          <h3>Curva de equity</h3>
          <div style="display:flex; gap:0.4rem; align-items:center;">
          </div>
        </div>
        <canvas id="equityChart" height="200"></canvas>
      </div>
      <!-- PnL chart -->
      <div class="chart-wrapper">
        <div class="chart-header" style="display:flex; justify-content:space-between; align-items:center; gap:0.5rem; flex-wrap:wrap;">
          <div style="display:flex; align-items:center; gap:0.5rem;">
            <h3 style="margin:0;">Rendimiento (%)</h3>
            <div class="toggle-btns" id="pnlToggle">
              <button data-range="daily">Diario</button>
              <button data-range="weekly">Semanal</button>
              <button data-range="monthly" class="active">Mensual</button>
            </div>
          </div>
          <!-- Reset button appears when filtering by bar -->
          <button id="resetGroupBtn" class="btn" style="display:none; padding:0.3rem 0.6rem; font-size:0.8rem;">Ver todo</button>
        </div>
        <canvas id="pnlChart" height="200"></canvas>
      </div>
    </div>
    <!-- Search bar -->
    <div class="search-bar">
      <input id="searchInput" type="text" placeholder="Buscar símbolo, fecha, comentario…">
      <div class="stats-display" id="tradeStats">0 trades</div>
    </div>
    <!-- Trades table -->
    <div style="overflow-x:auto;">
      <table>
       <thead>
  <tr>
    <th class="col-date">Fecha</th>
    <th>Símbolo</th>
    <th>Tipo</th>
    <th>Entrada</th>
    <th>Outcome</th>
    <th>PnL</th>
    <th>Comentario</th>
  </tr>
</thead>
        <tbody id="tradesBody"></tbody>
      </table>
    </div>

  
      <div class="chart-wrapper" style="grid-column: 1 / -1;">
  <div class="chart-header" style="display:flex; justify-content:space-between; align-items:center; gap:0.5rem; flex-wrap:wrap;">
    <h3 style="margin:0;">Simulación: TP fijo vs Parciales (R)</h3>

    <div style="display:flex; gap:0.4rem; align-items:center; flex-wrap:wrap;">
      <label style="color:var(--muted); font-size:0.85rem;">Rango:</label>
      <input id="simRMin" type="number" step="0.5" value="1" min="0.5"
        style="width:80px; padding:0.35rem 0.5rem; border:1px solid var(--border); border-radius:0.4rem; background:var(--surface); color:var(--text);">
      <span style="color:var(--muted);">a</span>
      <input id="simRMax" type="number" step="0.5" value="6" min="1"
        style="width:80px; padding:0.35rem 0.5rem; border:1px solid var(--border); border-radius:0.4rem; background:var(--surface); color:var(--text);">
      <label style="color:var(--muted); font-size:0.85rem;">Paso:</label>
      <input id="simStep" type="number" step="0.1" value="0.5" min="0.1"
        style="width:80px; padding:0.35rem 0.5rem; border:1px solid var(--border); border-radius:0.4rem; background:var(--surface); color:var(--text);">
      <button id="runSimBtn" class="btn" style="padding:0.35rem 0.7rem; font-size:0.85rem;">Simular</button>
    </div>
  </div>

  <canvas id="simChart" height="110"></canvas>

  <div style="overflow-x:auto; margin-top:0.8rem;">
    <table>
      <thead>
        <tr>
          <th>TP (R)</th>
          <th>Exp. TP fijo (R)</th>
          <th>WR fijo</th>
          <th>Exp. Parciales (R)</th>
          <th>WR parciales</th>
          <th>Δ (Fijo - Parciales)</th>
          <th>N</th>
        </tr>
      </thead>
      <tbody id="simTableBody"></tbody>
    </table>
  </div>
</div>
<!-- ===== Prop Firms Dashboard ===== -->
<div style="margin-top:2rem;">
  <h2 style="text-align:center; margin:0 0 0.75rem;">Prop Firms</h2>

  <div class="kpi-grid">
    <div class="kpi-card"><h3>Total Payouts</h3><div class="value" id="pfTotalPayouts">$0</div></div>
    <div class="kpi-card"><h3>Challenge Costs</h3><div class="value" id="pfChallengeCosts">$0</div></div>
    <div class="kpi-card"><h3>Refunds</h3><div class="value" id="pfRefunds">$0</div></div>
    <div class="kpi-card"><h3>Net Profit</h3><div class="value" id="pfNetProfit">$0</div></div>
    <div class="kpi-card"><h3>ROI</h3><div class="value" id="pfROI">0.00%</div></div>
    <div class="kpi-card"><h3>Payout Count</h3><div class="value" id="pfPayoutCount">0</div></div>
  </div>

  <div class="chart-wrapper">
    <div class="chart-header">
      <h3>Net cumulative P&amp;L (USD)</h3>
    </div>
    <canvas id="pfEquityChart" height="140"></canvas>
  </div>
</div>
    </div>
  </div>
   <!-- Lightbox para ampliar capturas -->
<div id="imgLightbox" style="
  position:fixed; inset:0; z-index:9999;
  background:rgba(0,0,0,0.85);
  display:none; align-items:center; justify-content:center;
  padding:24px;
">
  <img id="imgLightboxImg" src="" alt="captura ampliada" style="
    max-width:95vw; max-height:90vh;
    border-radius:12px;
    box-shadow:0 20px 60px rgba(0,0,0,0.5);
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(255,255,255,0.02);
  ">
<button type="button" id="imgLightboxClose" style="
position:absolute; top:16px; right:16px;
z-index:10000;
    padding:10px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.15);
    background:rgba(255,255,255,0.06);
    color:#fff;
    cursor:pointer;
    font-weight:700;
  ">✕</button>
</div>
  <!-- Modal for trade details -->
  <div class="modal" id="detailModal">
    <div class="modal-content">
      <h4>Detalles del Trade</h4>
      <div class="details" id="detailGrid"></div>
      <div class="images" id="detailImages"></div>
      <div class="modal-close"><button id="closeModalBtn">Cerrar</button></div>
    </div>
  </div>
  <script>
    function populatePairFilter(trades) {
  const sel = document.getElementById('pairFilter');
  if (!sel) return;

  const current = sel.value || 'ALL';

  const pairs = Array.from(new Set(
    (trades || [])
      .map(t => (t.symbol ?? '').toString().trim().toUpperCase())
      .filter(s => s.length > 0)
  )).sort();

  sel.innerHTML = '<option value="ALL">Todos</option>';
  pairs.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p;
    opt.textContent = p;
    sel.appendChild(opt);
  });

  sel.value = pairs.includes(current) ? current : 'ALL';
}
let CONF_OPTIONS = [];
let CONF_SELECTED = new Set();

function populateConfluenceFilter(trades) {
  const set = new Set();

  (trades || []).forEach(t => {
    const raw = String(t.confluences || '').trim();
    if (!raw) return;

    raw
      .split(/,|;/)              // <- robusto
      .map(x => x.trim())
      .filter(Boolean)
      .forEach(c => set.add(c));
  });

  CONF_OPTIONS = Array.from(set).sort();

  // mantener seleccionadas las que sigan existiendo
  CONF_SELECTED = new Set([...CONF_SELECTED].filter(x => CONF_OPTIONS.includes(x)));

  renderConfluenceDropdown();
  updateConfButtonLabel();
}
function getSelectedConfluences() {
  return Array.from(CONF_SELECTED);
}

function updateConfButtonLabel() {
  const el = document.getElementById('confBtnLabel');
  if (!el) return;

  const n = CONF_SELECTED.size;
  if (n === 0) el.textContent = 'Todas';
  else if (n === 1) el.textContent = [...CONF_SELECTED][0];
  else el.textContent = `${n} seleccionadas`;
}

function renderConfluenceDropdown(filterText = '') {
  const list = document.getElementById('confList');
  if (!list) return;

  const q = String(filterText || '').trim().toLowerCase();
  const items = !q ? CONF_OPTIONS : CONF_OPTIONS.filter(x => x.toLowerCase().includes(q));

  list.innerHTML = '';

  items.forEach(name => {
    const row = document.createElement('label');
    row.className = 'multi-select-item';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = CONF_SELECTED.has(name);

    cb.addEventListener('change', () => {
      if (cb.checked) CONF_SELECTED.add(name);
      else CONF_SELECTED.delete(name);

      updateConfButtonLabel();
      applyCurrentFilters();
    });

    const sp = document.createElement('span');
    sp.textContent = name;

    row.appendChild(cb);
    row.appendChild(sp);
    list.appendChild(row);
  });
}
    // Utility functions
    const $ = (id) => document.getElementById(id);
    const fmt2 = (num) => Number.isFinite(num) ? num.toFixed(2) : '0.00';
    const pct = (val) => Number.isFinite(val) ? (val * 100).toFixed(2) + '%' : '0%';
    const parseDate = (str) => {
      // Robust date parser for multiple formats:
      // Accepts ISO strings, DD/MM/YYYY, DD-MM-YYYY, serial numbers from Sheets/Excel.
      if (str === null || str === undefined) return null;

      // Serial number (numbers) from Google Sheets/Excel
      if (typeof str === "number" && Number.isFinite(str)) {
        const base = new Date(Date.UTC(1899, 11, 30)); // 1899-12-30
        const d = new Date(base.getTime() + str * 86400000);
        return isNaN(d) ? null : d;
      }

      const s = String(str).trim();
      if (!s) return null;

      // Try native Date parse for ISO and RFC compliant strings
      let d = new Date(s);
      if (!isNaN(d)) return d;

      // Support DD/MM/YYYY or DD-MM-YYYY with optional time HH:MM(:SS)
      const m = s.match(/^\s*(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?\s*$/);
      if (m) {
        let day = +m[1];
        let mon = +m[2];
        let year = +m[3];
        if (year < 100) year += 2000;
        const hh = +m[4] || 0;
        const mm = +m[5] || 0;
        const ss = +m[6] || 0;
        d = new Date(year, mon - 1, day, hh, mm, ss);
        return isNaN(d) ? null : d;
      }
      return null;
    };

    // Global declaration for range filter buttons.  This will be populated later in the script
    // and ensures that applyCurrentFilters and other functions can always access the variable
    // without triggering the temporal dead zone of a `const` declaration.  See later in the
    // script where `rangeButtons` is assigned to an array of button IDs.
    let rangeButtons = [];

    // Month abbreviations in Spanish for formatting dates
    const monthNames = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
    function formatPrettyDate(dateStr, withTime = false) {
  const d = parseDate(dateStr);
  if (!d) return String(dateStr || '');

  const day = String(d.getDate()).padStart(2, '0');
  const mon = monthNames[d.getMonth()] || '';
  const base = `${day}-${mon}`;

  if (!withTime) return base;

  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return `${base} ${hh}:${mm}`;
}
    // Format a date string key (YYYY-MM-DD, YYYY-MM, or YYYY-Wxx) into a shorter label
function formatDateLabel(label) {
  if (!label) return '';

  // semanas tipo 2026-W04
  if (label.includes('-W')) {
    const [year, week] = label.split('-W');
    return `S${week}`;
  }

  // Si es YYYY-MM-DD o YYYY-MM
  const parts = String(label).split('-');
  if (parts.length === 3) {
    const [y,m,d] = parts;
    const month = monthNames[parseInt(m,10)-1] || m;
    return `${d}-${month}`;
  }
  if (parts.length === 2) {
    const [y,m] = parts;
    const month = monthNames[parseInt(m,10)-1] || m;
    return `${month} ${y}`;
  }

  // ✅ Si llega algo como "2025/12/23 10:54" o cualquier fecha completa:
  // lo parseamos y lo mostramos como 23-Dic
  const d = parseDate(label);
  if (d) {
    const day = String(d.getDate()).padStart(2,'0');
    const mon = monthNames[d.getMonth()] || '';
    return `${day}-${mon}`;
  }

  return String(label);
}
    // Storage for trades
    let ALL_TRADES = [];
    let FILTERED_TRADES = [];
    let equityChart, pnlChart;
    let PF_ROWS = [];
let pfEquityChart = null;
let PF_TIMER = null;

    // User-defined capital (account size) used to calculate percentage returns
    let accountSize = 10000;


    // Flag to track whether a group-based filter is active (clicking PnL bar)
    let groupFilterActive = false;
let equityType = 'percentage';
    let pnlRange = 'monthly';
  

    // Crosshair plugin: draws a vertical line following the tooltip to act like a magnet
    const crosshairPlugin = {
      id: 'crosshair',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, chartArea: { top, bottom }, tooltip } = chart;
        if (!tooltip || tooltip.opacity === 0) return;
        const x = tooltip.caretX;
        ctx.save();
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, bottom);
        ctx.stroke();
        ctx.restore();
      }
    };
    // Register the plugin once
    Chart.register(crosshairPlugin);
    // Normalize trade row from CSV or JSON
    function normalize(raw) {
      // Extract fields with fallbacks
      const date = raw.date ?? raw.Date ?? raw.fecha ?? raw.Fecha ?? '';
      const pnl = raw.pnl ?? raw.PnL ?? raw.Pnl ?? raw.PNL ?? raw['pips sesion'] ?? raw['PIPS SESION'] ?? raw['pips semana'] ?? raw['PIPS SEMANA'] ?? 0;
      const balance =
  raw.balance ?? raw.Balance ?? raw.BALANCE ?? raw.capital ?? raw.Capital ?? raw.CAPITAL ?? null;

const cashflow =
  raw.cashflow ?? raw.Cashflow ?? raw.CASHFLOW ?? raw.deposito ?? raw.Deposito ?? raw.DEPOSITO ??
  raw.retiro ?? raw.Retiro ?? raw.RETIRO ?? 0;
      // Possible pips (lo máximo que se pudo capturar).  Buscamos distintos
      // nombres habituales en los registros para soportar diferentes formatos.
      // Determine possible pips (lo máximo que se pudo capturar).  Buscamos distintos nombres habituales en los registros para soportar diferentes formatos.
      let possibleRaw = raw.possible ?? raw.possible_pips ?? raw.possiblePips ?? raw['pips posibles'] ?? raw['PIPS POSIBLES'] ?? raw['pips posibles sesion'] ?? raw['PIPS POSIBLES SESION'] ?? raw['pips posibles semana'] ?? raw['PIPS POSIBLES SEMANA'] ?? null;
      // Also support English/uppercase column names 'Possible' or 'POSSIBLE'
      if (possibleRaw === null || possibleRaw === undefined) {
        if (raw.Possible !== undefined && raw.Possible !== null) {
          possibleRaw = raw.Possible;
        } else if (raw.POSSIBLE !== undefined && raw.POSSIBLE !== null) {
          possibleRaw = raw.POSSIBLE;
        }
      }
      const symbol = raw.symbol ?? raw.Symbol ?? raw.par ?? raw.PAR ?? '';
      // OUTCOME: WIN / LOSS / BE
const outcomeRaw =
  raw.OUTCOME ?? raw.outcome ?? raw.Outcome ??
  raw['OUTCOME'] ?? raw['Outcome'] ?? raw['outcome'] ?? '';
const outcome = String(outcomeRaw).trim().toUpperCase();
      let type = raw.side ?? raw.Side ?? raw['tipo'] ?? raw['TIPO D'] ?? '';
      // Support English column 'Type'
      if (!type) type = raw.Type ?? '';
const comment = raw.comment ?? raw.Comment ?? raw.COMMENT ?? '';
      let tf = raw['multi-s'] ?? raw['Multi-s'] ?? raw['Multi-s …'] ?? '';
      // Support timeframe column 'TF' or lowercase 'tf'
      if (!tf) tf = raw.TF ?? raw.tf ?? '';
      // Entrada (en tu Sheet viene como "Entrada")
const entry =
  raw.entry ?? raw.Entry ??
  raw.entrada ?? raw.Entrada ?? raw.ENTRADA ?? raw['ENTRADA…'] ?? '';

// SL (en tu Sheet viene como "SL")
const sl =
  raw.sl ?? raw.SL ?? raw.Sl ?? '';

// Objetivo / TP (en tu Sheet viene como "TP")
const target =
  raw.target ?? raw.Target ??
  raw.tp ?? raw.TP ?? raw.Tp ?? '';

// Setup
let setup = raw.setup ?? raw.Setup ?? raw['SET UP'] ?? '';
if (!setup) setup = raw['Set up'] ?? raw['SET UP'] ?? '';

const confluences =
  raw.confluences ?? raw.Confluences ?? raw.CONFLUENCES ?? '';
// Imagen (en tu Sheet viene como "CAPTURA"; también soporta "captura" o "image")
const img =
  raw.image ?? raw.img ?? raw.screenshot ??
  raw.captura ?? raw.Captura ?? raw.CAPTURA ??
  raw['captura'] ?? raw['CAPTURA'] ?? '';
 const slVal = raw.SL ?? raw.sl ?? raw['Sl'] ?? raw['sl'] ?? null;

// ✅ TP1 / TP2 (soporta variantes comunes)
const tp1Val =
  raw.TP1 ?? raw.tp1 ?? raw['Tp1'] ?? raw['tp1'] ??
  raw['TP 1'] ?? raw['TP_1'] ?? raw['TP-1'] ?? null;

const tp2Val =
  raw.TP2 ?? raw.tp2 ?? raw['Tp2'] ?? raw['tp2'] ??
  raw['TP 2'] ?? raw['TP_2'] ?? raw['TP-2'] ?? null;

// ✅ TP legacy (si todavía existe la columna "TP")
const tpLegacyVal =
  raw.TP ?? raw.tp ?? raw['Tp'] ?? raw['tp'] ?? null;

const mfeVal = raw.MFE ?? raw.mfe ?? raw['Mfe'] ?? raw['mfe'] ?? null;
      return {
        date: String(date).trim(),
        pnl: Number(pnl) || 0,
        symbol: String(symbol).trim(),
        outcome: outcome,
        type: String(type).trim(),
        comment: String(comment).trim(),
        confluences: String(confluences).trim(),
        tf: String(tf).trim(),
        entry: entry ? String(entry).trim() : '',
        sl: sl ? String(sl).trim() : '',
        target: target ? String(target).trim() : '',
        setup: String(setup).trim(),
        image: img ? String(img).trim() : '',
        balance: (balance !== null && balance !== undefined && String(balance).trim() !== '') ? (Number(balance) || 0) : null,
cashflow: Number(cashflow) || 0,
        // Valor máximo posible en pips.  Puede ser nulo si el registro no lo incluye.
        possible: possibleRaw !== null ? (Number(possibleRaw) || 0) : null
        ,
        // New properties for RR metrics (numeric).  Null if missing.
        sl_pips: (slVal !== null && slVal !== undefined && String(slVal).trim() !== '') ? (Number(slVal) || 0) : null,

// ✅ nuevos campos
tp1_pips: (tp1Val !== null && tp1Val !== undefined && String(tp1Val).trim() !== '') ? (Number(tp1Val) || 0) : null,
tp2_pips: (tp2Val !== null && tp2Val !== undefined && String(tp2Val).trim() !== '') ? (Number(tp2Val) || 0) : null,

// ✅ tp_pips queda como legacy (TP viejo), NO como TP2
tp_pips: (tpLegacyVal !== null && tpLegacyVal !== undefined && String(tpLegacyVal).trim() !== '') ? (Number(tpLegacyVal) || 0) : null,

mfe_pips: (mfeVal !== null && mfeVal !== undefined && String(mfeVal).trim() !== '') ? (Number(mfeVal) || 0) : null
      };
    }
    // Group trades by function key
    function groupBy(trades, fn) {
      const map = new Map();
      trades.forEach(t => {
        const d = parseDate(t.date);
        if (!d) return;
        const key = fn(d);
        map.set(key, (map.get(key) || 0) + t.pnl);
      });
      return Array.from(map.entries()).sort((a,b) => a[0].localeCompare(b[0]));
    }
    const weekKey = (d) => {
      const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
      date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay() || 7));
      const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
      const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
      return `${date.getUTCFullYear()}-W${String(weekNo).padStart(2,'0')}`;
    };
    const monthKey = (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
    // Day key for daily grouping
    const dayKey = (d) => {
      // return ISO date string (YYYY-MM-DD)
      return d.toISOString().slice(0,10);
    };
    function computeTWR(trades) {
  const sorted = trades
    .slice()
    .filter(t => t.balance !== null && t.balance !== undefined)
    .sort((a,b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0));

  if (sorted.length < 2) return 0;

  let twr = 1;

  // inicio del primer tramo
  let startBal = sorted[0].balance;

  for (let i = 1; i < sorted.length; i++) {
    const t = sorted[i];

    // si hay cashflow, cerramos el tramo justo ANTES del cashflow
    if ((Number(t.cashflow) || 0) !== 0) {
      const endBal = sorted[i - 1].balance;

      if (startBal && startBal !== 0) {
        twr *= (endBal / startBal);
      }

      // el siguiente tramo empieza DESPUÉS del cashflow
      startBal = t.balance;
    }
  }

  // cerrar el último tramo
  const lastBal = sorted[sorted.length - 1].balance;
  if (startBal && startBal !== 0) {
    twr *= (lastBal / startBal);
  }

  return twr - 1; // retorno total (ej. 0.12 = +12%)
}
function computeTWRIndexSeries(trades) {
  const sorted = (trades || [])
    .slice()
    .filter(t => t.balance !== null && t.balance !== undefined && isFinite(Number(t.balance)))
    .sort((a,b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0));

  if (!sorted.length) return [];

  let twr = 1;
  let startBal = Number(sorted[0].balance) || 0;

  const out = [];

  for (let i = 0; i < sorted.length; i++) {
    const t = sorted[i];
    const bal = Number(t.balance) || 0;
    const cf  = Number(t.cashflow) || 0;

    if (i > 0 && cf !== 0) {
      const prevBal = Number(sorted[i - 1].balance) || 0;
      if (startBal) twr *= (prevBal / startBal);
      startBal = bal;
    }

    const idx = startBal ? (twr * (bal / startBal)) : twr;
    out.push({ date: t.date, idx });
  }

  return out;
}
    // Metrics calculation
function computeMetrics(trades) {
  const n = trades.length;
  const total = trades.reduce((acc, t) => acc + (Number(t.pnl) || 0), 0);

  // ===== Win rate basado en OUTCOME =====
  const wins = trades.filter(t => String(t.outcome || '').toUpperCase() === 'WIN').length;
const losses = trades.filter(t => String(t.outcome || '').toUpperCase() === 'LOSS').length;
const winRate = (wins + losses) > 0 ? wins / (wins + losses) : 0;

  // ===== Ordenar trades por fecha =====
  const sorted = trades
    .slice()
    .sort((a, b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0));

  // ===== Equity series (SIEMPRE válida) =====
  let equity = 0;
  const eqSeries = [];
  sorted.forEach(t => {
    equity += (Number(t.pnl) || 0);
    eqSeries.push({
      date: t.date,
      equity: equity,
      balance: (t.balance !== null && t.balance !== undefined && !isNaN(Number(t.balance))) ? (Number(t.balance) || 0) : null,
      cashflow: Number(t.cashflow) || 0
    });
  });

  // ===== MaxDD / Sharpe / Calmar coherentes (basados en TWR) =====
  let maxDD = 0;
  let sharpe = 0;
  let calmar = 0;

  const hasBalance = eqSeries.some(p => p.balance !== null && p.balance !== undefined && !isNaN(Number(p.balance)));

  // Serie TWR (para equity% y retornos por periodo)
  const twrSeries = hasBalance ? computeTWRIndexSeries(sorted) : [];

  if (twrSeries.length) {
    // Max drawdown sobre TWR
    let peak = twrSeries[0].idx || 1;
    let worstDD = 0;
    for (const p of twrSeries) {
      if (p.idx > peak) peak = p.idx;
      const dd = peak ? (p.idx / peak) - 1 : 0;
      if (dd < worstDD) worstDD = dd;
    }
    maxDD = worstDD;

    // Retornos mensuales usando TWR
    const monthMap = new Map();
    for (const p of twrSeries) {
      const d = parseDate(p.date);
      if (!d) continue;
      const key = monthKey(d);
      if (!monthMap.has(key)) monthMap.set(key, { first: p.idx, last: p.idx });
      else monthMap.get(key).last = p.idx;
    }

    const monthlyReturns = Array.from(monthMap.values())
      .map(m => (m.first ? (m.last / m.first) - 1 : 0));

    // Sharpe mensual anualizado
    if (monthlyReturns.length >= 2) {
      const mean = monthlyReturns.reduce((a, b) => a + b, 0) / monthlyReturns.length;
      const variance = monthlyReturns.reduce((a, r) => a + Math.pow(r - mean, 2), 0) / (monthlyReturns.length - 1);
      const stdev = Math.sqrt(variance);
      sharpe = stdev ? (mean / stdev) * Math.sqrt(12) : 0;
    } else {
      sharpe = 0;
    }

    // Calmar = retorno anualizado / |maxDD|
    const totalReturn = (twrSeries[twrSeries.length - 1].idx / (twrSeries[0].idx || 1)) - 1;
    const months = Math.max(1, monthMap.size);
    const annualReturn = Math.pow(1 + totalReturn, 12 / months) - 1;
calmar = Math.abs(maxDD) > 0 ? (totalReturn / Math.abs(maxDD)) : 0;
  } else {
    maxDD = 0;
    sharpe = 0;
    calmar = 0;
  }

  // ===== Profit factor / Payoff / Expectancy =====
  let totalWins = 0, totalLosses = 0;
  let countWins = 0, countLosses = 0;

  trades.forEach(t => {
    const p = Number(t.pnl) || 0;
    if (p > 0) {
      totalWins += p;
      countWins++;
    } else if (p < 0) {
      totalLosses += Math.abs(p);
      countLosses++;
    }
  });

  const profitFactor = totalLosses === 0 ? 0 : (totalWins / totalLosses);
  const avgWin = countWins ? totalWins / countWins : 0;
  const avgLoss = countLosses ? -(totalLosses / countLosses) : 0;
  const payoffRatio = avgLoss === 0 ? 0 : (avgWin / Math.abs(avgLoss));
  const expectancy = (winRate * avgWin) + ((1 - winRate) * avgLoss);

  return {
    total,
    winRate,
    maxDD,
    sharpe,
    calmar,
    eqSeries,
    profitFactor,
    payoffRatio,
    expectancy,
    twrSeries // ✅ IMPORTANTE: nuevo
  };
}
function normalizePropFirm(raw) {
  const date   = raw.date ?? raw.Date ?? raw.data ?? raw.Data ?? '';
  const firm   = raw.firm ?? raw.Firm ?? '';
  const acct   = raw.account ?? raw.Account ?? '';
  const type   = raw.type ?? raw.Type ?? '';
  const amountRaw = raw.amount ?? raw.Amount ?? 0;
  const notes  = raw.notes ?? raw.Notes ?? '';

  const amount = Number(String(amountRaw).replace(/,/g,'').replace(/[^0-9.\-]/g,'')) || 0;

  return {
    date: String(date).trim(),
    firm: String(firm).trim(),
    account: String(acct).trim(),
    type: String(type).trim(),
    amount,
    notes: String(notes).trim()
  };
}

function money(n) {
  const v = Number(n) || 0;
  const sign = v < 0 ? '-' : '';
  const abs = Math.abs(v);
  return sign + '$' + abs.toLocaleString('en-US', { maximumFractionDigits: 2 });
}

function computePropFirmMetrics(rows) {
  const clean = (rows || [])
.filter(r => {
  const d = parseDate(r.date);
  return d && !isNaN(d.getTime());
})
    .sort((a,b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0));

  const sumByType = (t) =>
    clean.filter(r => String(r.type).toLowerCase() === t.toLowerCase())
         .reduce((a,r) => a + (Number(r.amount)||0), 0);

  const payouts  = sumByType('Payout');   // +
  const refunds  = sumByType('Refund');   // +
  const purchase = sumByType('Purchase'); // -
  const fees     = sumByType('Fee');      // -

  const netProfit = clean.reduce((a,r) => a + (Number(r.amount)||0), 0);

  const invested = Math.abs(purchase) + Math.abs(fees);
  const roi = invested > 0 ? (netProfit / invested) : 0;

  const payoutCount = clean.filter(r => String(r.type).toLowerCase() === 'payout').length;

  // Equity curve = acumulado neto
  let cum = 0;
  const series = clean.map(r => {
    cum += (Number(r.amount)||0);
    return { date: r.date, value: cum };
  });

  return { payouts, refunds, purchase, fees, netProfit, roi, payoutCount, series };
}

function renderPropFirmDashboard(rows) {
  const m = computePropFirmMetrics(rows);

  const elPayouts  = document.getElementById('pfTotalPayouts');
  const elCosts    = document.getElementById('pfChallengeCosts');
  const elRefunds  = document.getElementById('pfRefunds');
  const elNet      = document.getElementById('pfNetProfit');
  const elROI      = document.getElementById('pfROI');
  const elCount    = document.getElementById('pfPayoutCount');

  if (elPayouts) elPayouts.textContent = money(m.payouts);
  if (elCosts)   elCosts.textContent   = money(Math.abs(m.purchase));
  if (elRefunds) elRefunds.textContent = money(m.refunds);
  if (elNet)     elNet.textContent     = money(m.netProfit);
  if (elROI)     elROI.textContent     = (m.roi * 100).toFixed(2) + '%';
  if (elCount)   elCount.textContent   = String(m.payoutCount);

// --- Insertar puntos extra cuando cruza 0 (para cambiar color exacto) ---
const src = m.series
  .map(p => ({ date: p.date, value: Number(p.value) || 0 }))
  .filter(p => p.date);

const labels2 = [];
const data2 = [];

function toMs(d) {
  const dt = parseDate(d);
  return dt ? dt.getTime() : null;
}

for (let i = 0; i < src.length; i++) {
  const cur = src[i];
  labels2.push(cur.date);
  data2.push(cur.value);

  if (i === src.length - 1) break;

  const next = src[i + 1];

  // Si hay cruce de signo entre cur y next (incluye cruce exacto)
  const y0 = cur.value;
  const y1 = next.value;

  if ((y0 < 0 && y1 > 0) || (y0 > 0 && y1 < 0)) {
    // Interpolación lineal para encontrar el punto donde y=0
    const t = y0 / (y0 - y1); // proporción entre 0 y 1
    const ms0 = toMs(cur.date);
    const ms1 = toMs(next.date);

    if (ms0 !== null && ms1 !== null) {
      const msCross = Math.round(ms0 + (ms1 - ms0) * t);
      const crossDate = new Date(msCross);

      // Etiqueta "real" para el eje: guardamos ISO (Chart ya lo muestra con tu formatDateLabel)
      const crossLabel = crossDate.toISOString().slice(0, 19).replace('T',' ');

      labels2.push(crossLabel);
      data2.push(0);
    } else {
      // fallback: si no se puede interpolar la fecha, igual mete el 0 con el label de next
      labels2.push(next.date);
      data2.push(0);
    }
  }
}

  const canvas = document.getElementById('pfEquityChart');
  if (!canvas) return;

  if (pfEquityChart) pfEquityChart.destroy();
pfEquityChart = new Chart(canvas, {
  type: 'line',
  data: {
    labels: labels2,
    datasets: [{
      label: 'Net cumulative P&L ($)',
      data: data2,
      pointRadius: 0,
      tension: 0.25,
      borderWidth: 2,

      // ✅ Relleno separado arriba/abajo de 0
      fill: {
        target: { value: 0 },
        above: 'rgba(34,197,94,0.18)',
        below: 'rgba(220,38,38,0.18)'
      },

      // ✅ Línea arriba/abajo de 0 (por segmentos)
      segment: {
        borderColor: (ctx) => (ctx.p0.parsed.y < 0 ? 'rgb(220,38,38)' : 'rgb(34,197,94)')
      }
    }]
  },
  options: {
    responsive: true,
    interaction: { mode: 'index', intersect: false, axis: 'x' },
    plugins: { legend: { display: false } },
    scales: {
      x: {
        ticks: {
          color: '#94a3b8',
          callback: (v, i) => formatDateLabel(labels2[i])
        },
        grid: { color: 'rgba(255,255,255,0.05)' }
      },
      y: {
        ticks: { color: '#94a3b8' },
        grid: { color: 'rgba(255,255,255,0.05)' }
      }
    }
  }
});
}
function simulateStrategies2R(trades) {
  if (!Array.isArray(trades) || trades.length === 0) {
    return { parcial: 0, fija: 0 };
  }

  let sumParcial = 0;
  let sumFija = 0;
  let count = 0;

  trades.forEach(t => {
    const sl = Number(t.sl_pips) || 0;
    const mfe = Number(t.mfe_pips) || 0;
    const outcome = String(t.outcome || '').toUpperCase();

    if (!sl || sl <= 0) return;

    const mfeR = mfe / sl;

    // ===== Estrategia fija 2R =====
    let rFija = 0;

    if (mfeR >= 2) {
      rFija = 2;
    } else {
      if (outcome === 'LOSS') rFija = -1;
      else if (outcome === 'BE') rFija = 0;
      else if (outcome === 'WIN') {
        const pnl = Number(t.pnl) || 0;
        rFija = pnl / sl;
      }
    }

    // ===== Estrategia parcial (50% en 1R, BE en 2R, TP restante en 2R) =====
    let rParcial = 0;

    if (mfeR < 1) {
      if (outcome === 'LOSS') rParcial = -1;
      else if (outcome === 'BE') rParcial = 0;
      else if (outcome === 'WIN') {
        const pnl = Number(t.pnl) || 0;
        rParcial = pnl / sl;
      }
    }
    else if (mfeR >= 1 && mfeR < 2) {
      rParcial = 0.5; // solo parcial
    }
    else if (mfeR >= 2) {
      rParcial = 0.5 + (0.5 * 2); // parcial + resto a 2R
    }

    sumParcial += rParcial;
    sumFija += rFija;
    count++;
  });

  return {
    parcial: count ? sumParcial / count : 0,
    fija: count ? sumFija / count : 0
  };
}
    function computeCaptureMetrics(trades) {
      const dayMap = {};
      const weekMap = {};
      trades.forEach(t => {
        const date = parseDate(t.date);
        if (!date) return;
        const day = dayKey(date);
        const week = weekKey(date);
        dayMap[day] = dayMap[day] || { real: 0, possible: 0 };
        weekMap[week] = weekMap[week] || { real: 0, possible: 0 };
        // real always accumulates from pnl
        dayMap[day].real  += Number(t.pnl) || 0;
        weekMap[week].real += Number(t.pnl) || 0;
        // only accumulate possible if the property exists and is finite
        if (t.possible != null && isFinite(t.possible)) {
          dayMap[day].possible  += Number(t.possible);
          weekMap[week].possible += Number(t.possible);
        }
      });
      // Compute ratios and extra pips
      let dayCaptureSum = 0;
      let dayCount = 0;
      let dayExtra = 0;
      Object.keys(dayMap).forEach(key => {
        const { real, possible } = dayMap[key];
        if (possible > 0) {
          dayCaptureSum += real / possible;
          dayCount++;
          dayExtra += (possible - real);
        }
      });
      let weekCaptureSum = 0;
      let weekCount = 0;
      let weekExtra = 0;
      Object.keys(weekMap).forEach(key => {
        const { real, possible } = weekMap[key];
        if (possible > 0) {
          weekCaptureSum += real / possible;
          weekCount++;
          weekExtra += (possible - real);
        }
      });
      const dayAvgCapture  = dayCount  ? dayCaptureSum  / dayCount  : 0;
      const weekAvgCapture = weekCount ? weekCaptureSum / weekCount : 0;
      return {
        dayAvgCapture,
        dayTotalExtra: dayExtra,
        weekAvgCapture,
        weekTotalExtra: weekExtra
      };
    }
function getField(obj, name) {
  if (!obj) return undefined;
  const target = String(name).trim().toLowerCase();
  const key = Object.keys(obj).find(k => String(k).trim().toLowerCase() === target);
  return key ? obj[key] : undefined;
}
function median(arr) {
  const a = (arr || []).filter(v => Number.isFinite(v)).sort((x,y) => x - y);
  const n = a.length;
  if (!n) return 0;
  const mid = Math.floor(n / 2);
  return n % 2 ? a[mid] : (a[mid - 1] + a[mid]) / 2;
}
function toNum(v) {
  if (v === null || v === undefined) return NaN;
  // Convierte strings tipo "60.00", " 60 ", "$6.00" -> 60
  const s = String(v).trim().replace(/[^0-9.\-]/g, '');
  if (s === '' || s === '-' || s === '.' || s === '-.' ) return NaN;
  return Number(s);
}
    /**
     * Compute risk‑reward (RR) metrics for a set of trades.  Each trade should
     * include `sl_pips`, `tp_pips` and `mfe_pips` values.  The function returns
     * the average RR actually achieved (TP/SL), the average RR potential offered
     * by the market (MFE/SL), the median of the potential RR values, and the
     * 80th percentile of the potential RR values.  A trade is skipped in the
     * averages if its `sl_pips` is zero or missing.
     */
    function computeRRMetrics(trades) {
  let sumReal = 0, countReal = 0;
  let sumPot  = 0, countPot  = 0;
  const potList = [];

  trades.forEach(t => {
    const sl = Number(t.sl_pips);
    if (!Number.isFinite(sl) || sl === 0) return;

    const mfe = Number(t.mfe_pips);
    if (Number.isFinite(mfe)) {
      const r = mfe / sl;
      sumPot += r;
      countPot++;
      potList.push(r);
    }

    // ✅ RR real: si hay TP1/TP2 usar neto 50/50. Si no, usar TP legacy.
    const tp1 = Number(t.tp1_pips);
    const tp2 = Number(t.tp2_pips);

    let tpNet = null;

    if (Number.isFinite(tp1) || Number.isFinite(tp2)) {
      const a = Number.isFinite(tp1) ? tp1 : 0;
      const b = Number.isFinite(tp2) ? tp2 : 0;
      tpNet = 0.5 * a + 0.5 * b;
    } else {
      const tpLegacy = Number(t.tp_pips);
      if (Number.isFinite(tpLegacy)) tpNet = tpLegacy;
    }

    if (tpNet !== null) {
      sumReal += tpNet / sl;
      countReal++;
    }
  });

  const avgReal = countReal ? (sumReal / countReal) : 0;
  const avgPot  = countPot  ? (sumPot  / countPot)  : 0;
  const avgGap  = (countReal && countPot) ? (avgPot - avgReal) : 0;

  potList.sort((a,b) => a - b);
  let median = 0, p80 = 0;
  const n = potList.length;

  if (n > 0) {
    const mid = Math.floor(n / 2);
    median = n % 2 ? potList[mid] : (potList[mid - 1] + potList[mid]) / 2;

    const idx = 0.8 * (n - 1);
    const lower = Math.floor(idx);
    const upper = Math.ceil(idx);
    p80 = (lower === upper)
      ? potList[lower]
      : (potList[lower] + (potList[upper] - potList[lower]) * (idx - lower));
  }

  return { avgReal, avgPot, avgGap, medianPot: median, p80Pot: p80 };
}

    /**
     * Compute statistics on the max favourable excursion (MFE) values in pips.
     * Returns the 80% trimmed mean (removing 10% lowest and 10% highest values)
     * and the 80th percentile (p80) of the distribution.  Trades with a null or
     * non‑finite `mfe_pips` value are ignored.
     */
    /**
     * Compute statistics on the max favourable excursion (MFE) values.  This helper
     * can operate either on raw pips or on risk‑adjusted ratios.  When
     * `usePips` is true (the default), it uses the `mfe_pips` property on
     * trades.  Otherwise it derives a ratio by dividing the MFE in pips by
     * the absolute value of the stop‑loss in pips.  Trades lacking an
     * appropriate MFE value or, in ratio mode, a valid stop size are
     * ignored.  The function returns two values: the mean of the central
     * 80 % of the distribution (10 % trimmed mean) and the 80th percentile.
     *
     * @param {Array<Object>} trades List of trade objects to process.
     * @param {boolean} [usePips=true] Whether to compute using raw pips or
     *   risk‑adjusted ratios.  If false, the ratio is `mfe_pips / abs(sl_pips)`.
     * @returns {{avg80: number, p80: number}} The 80 % trimmed mean and
     *   80th percentile of the chosen values.
     */
    function computeMFEStats(trades, usePips = true) {
      const values = [];
      trades.forEach(t => {
        const mfe = t.mfe_pips;
        if (mfe == null || !isFinite(mfe)) return;
        if (usePips) {
          values.push(Number(mfe));
        } else {
          const sl = t.sl_pips;
          if (sl == null || !isFinite(sl) || sl === 0) return;
          values.push(mfe / Math.abs(sl));
        }
      });
      if (!values.length) return { avg80: 0, p80: 0 };
      values.sort((a, b) => a - b);
      const n = values.length;
      // Calculate trimmed mean by removing the lowest 10 % and highest 10 %
      const lowIndex = Math.floor(n * 0.1);
      const highIndex = Math.ceil(n * 0.9) - 1;
      const trimmed = values.slice(lowIndex, highIndex + 1);
      const sumTrim = trimmed.reduce((acc, val) => acc + val, 0);
      let avg80 = trimmed.length ? sumTrim / trimmed.length : 0;
      // Historically this metric has been scaled by 0.8 to correspond
      // with the proportion of data retained after trimming (80 %).  Keep
      // this behaviour so that existing dashboards retain comparable
      // values.
      avg80 = avg80 * 0.8;
      // 80th percentile using linear interpolation
      const pIdx = 0.8 * (n - 1);
      const lower = Math.floor(pIdx);
      const upper = Math.ceil(pIdx);
      const p80 = (lower === upper)
        ? values[lower]
        : (values[lower] + (values[upper] - values[lower]) * (pIdx - lower));
      return { avg80, p80 };
    }
// TP óptimo considerando tu estrategia:
// - Si llega a 1R, tomas 50% (ganas +0.5R)
// - NO mueves a BE hasta 2R
// - Si llega a 2R, mueves SL a BE y ya no pierdes (te quedas con +0.5R)
// - Si llega al TP final (tpR), cierras el 50% restante a tpR => total = 0.5R + 0.5*tpR
// TP óptimo considerando tu estrategia REAL:
// - Si llega a 1R, tomas 50% => +0.5R
// - NO mueves a BE hasta 2R
// - Si llega a 1R pero NO a 2R: el 50% restante sigue con SL -> asume que termina en SL => -0.5R
//   => neto = 0R
// - Si llega a 2R, mueves SL a BE: si no llega al TP final, el resto termina BE => neto = +0.5R
// - Si llega al TP final (tpR): neto = +0.5R + 0.5*tpR
function computeTPOptimoConParciales(trades) {
  const rows = [];

  for (const t of trades) {
    const sl  = Number(t.sl_pips);
    const mfe = Number(t.mfe_pips);
    if (!Number.isFinite(sl) || sl <= 0) continue;
    if (!Number.isFinite(mfe) || mfe <= 0) continue;
    rows.push({ sl, mfe });
  }

  if (rows.length < 3) return null;

  const maxR = Math.max(...rows.map(r => r.mfe / r.sl));
  let bestTPR = null;
  let bestExp = -Infinity;

  // buscamos TP desde 1R hasta maxR
  for (let tpR = 1.0; tpR <= maxR; tpR += 0.1) {
    let sum = 0;

    for (const r of rows) {
      const mfeR = r.mfe / r.sl;

      let resultR;

      if (mfeR < 1) {
        // nunca llegó al parcial -> asumimos SL completo
        resultR = -1;
      } else if (mfeR < 2) {
        // llegó a 1R (parcial +0.5R) pero NO a 2R, nunca moviste a BE:
        // asumimos que el 50% restante termina en SL (-0.5R)
        // neto = 0R
        resultR = 0;
      } else if (mfeR < tpR) {
        // llegó a 2R, mueves a BE, pero no alcanzó TP final:
        // te quedas con el parcial (+0.5R), el resto BE
        resultR = 0.5;
      } else {
        // alcanzó TP final:
        // 50% en 1R => +0.5R
        // 50% en tpR => +0.5*tpR
        resultR = 0.5 + 0.5 * tpR;
      }

      sum += resultR;
    }

    const exp = sum / rows.length;
    if (exp > bestExp) {
      bestExp = exp;
      bestTPR = tpR;
    }
  }

  return { tpR: bestTPR, expectancy: bestExp };
}


// TP óptimo “máx. expectancia” en PIPS (tu KPI actual, lo dejamos intacto)
function computeTPOptimoMaxExpectancia(trades) {
  const valid = trades.filter(t =>
    Number.isFinite(t.mfe_pips) && t.mfe_pips >= 0 &&
    Number.isFinite(t.sl_pips) && t.sl_pips > 0
  );

  if (!valid.length) return null;

  const maxMFE = Math.max(...valid.map(t => t.mfe_pips));
  const step = 5;

  let bestTP = null;
  let bestExpectancy = -Infinity;

  for (let tp = step; tp <= maxMFE; tp += step) {
    let total = 0;

    for (const t of valid) {
      if (t.mfe_pips >= tp) {
        total += tp;
      } else {
        total -= t.sl_pips;
      }
    }

    const expectancy = total / valid.length;

    if (expectancy > bestExpectancy) {
      bestExpectancy = expectancy;
      bestTP = tp;
    }
  }

  return { tp: bestTP, expectancy: bestExpectancy };
}
function getTradeMinutes(trade) {
  const d = parseDate(trade.date);
  if (!d) return null;
  return d.getHours() * 60 + d.getMinutes();
}
function timeToMinutes(hhmm) {
  if (!hhmm) return 0;
  const parts = String(hhmm).split(':');
  const hh = parseInt(parts[0], 10) || 0;
  const mm = parseInt(parts[1], 10) || 0;
  return hh * 60 + mm;
}
function isRealTradeRow(t) {
  const pnl = Number(t?.pnl) || 0;
  const cf  = Number(t?.cashflow) || 0;

  // Si es un cashflow y no hay pnl, NO es trade
  if (cf !== 0 && pnl === 0) return false;

  // Opcional: si viene sin símbolo y sin tipo, tampoco lo consideres trade
  const sym = String(t?.symbol || '').trim();
  const type = String(t?.type || '').trim();
  if (!sym && !type && pnl === 0) return false;

  return true;
}
// ===== Comparador de estrategias (TP fijo vs parciales) =====
function strategyFixedTP_R(trades, tpR) {
  const rows = [];

  for (const t of trades) {
    const sl  = Number(t.sl_pips);
    const mfe = Number(t.mfe_pips);
    if (!Number.isFinite(sl) || sl <= 0) continue;
    if (!Number.isFinite(mfe) || mfe < 0) continue;

    const mfeR = mfe / sl;
    const resultR = (mfeR >= tpR) ? tpR : -1;
    rows.push(resultR);
  }

  if (!rows.length) return { expectancy: 0, winRate: 0, n: 0 };

  const expectancy = rows.reduce((a,b) => a + b, 0) / rows.length;

  const wins = rows.filter(r => r > 0).length;
  const losses = rows.filter(r => r < 0).length;
  const winRate = (wins + losses) ? (wins / (wins + losses)) : 0;

  return { expectancy, winRate, n: rows.length };
}

function strategyPartial_R(trades, tpR, partialAtR = 1, beMoveR = 2, partialPct = 0.5) {
  const rows = [];

  for (const t of trades) {
    const sl  = Number(t.sl_pips);
    const mfe = Number(t.mfe_pips);
    if (!Number.isFinite(sl) || sl <= 0) continue;
    if (!Number.isFinite(mfe) || mfe < 0) continue;

    const mfeR = mfe / sl;
    let resultR;

    if (mfeR < partialAtR) {
      resultR = -1;
    } else if (mfeR < beMoveR) {
      resultR = (partialPct * partialAtR) + ((1 - partialPct) * (-1));
      // = 0R con 50% en 1R
    } else if (mfeR < tpR) {
      resultR = partialPct * partialAtR; // +0.5R
    } else {
      resultR = (partialPct * partialAtR) + ((1 - partialPct) * tpR);
    }

    rows.push(resultR);
  }

  if (!rows.length) return { expectancy: 0, winRate: 0, n: 0 };

  const expectancy = rows.reduce((a,b) => a + b, 0) / rows.length;

  const wins = rows.filter(r => r > 0).length;
  const losses = rows.filter(r => r < 0).length;
  const winRate = (wins + losses) ? (wins / (wins + losses)) : 0;

  return { expectancy, winRate, n: rows.length };
}

function compareStrategies_R(trades, rMin = 2, rMax = 5, step = 0.5) {
  const out = [];
  for (let tpR = rMin; tpR <= rMax + 1e-9; tpR += step) {
    const fixed = strategyFixedTP_R(trades, tpR);
    const part  = strategyPartial_R(trades, tpR, 1, 2, 0.5);

    out.push({
      TP_R: Number(tpR.toFixed(2)),
      Exp_Fija_R: Number(fixed.expectancy.toFixed(3)),
      WR_Fija: fixed.winRate,
      Exp_Parcial_R: Number(part.expectancy.toFixed(3)),
      WR_Parcial: part.winRate,
      Delta_Fija_Menos_Parcial: Number((fixed.expectancy - part.expectancy).toFixed(3)),
      N: Math.min(fixed.n, part.n)
    });
  }
  return out;
}
    // Render metrics and charts
    function renderAll(trades) {

// ===== 1) Aplicar filtros combinables (Hora + Par) =====
let filteredTrades = Array.isArray(trades) ? trades.slice() : [];
// 1A) Filtro por PAR
const pairEl = document.getElementById('pairFilter');
if (pairEl && pairEl.value && pairEl.value !== 'ALL') {
  const target = pairEl.value.toString().trim().toUpperCase();
  filteredTrades = filteredTrades.filter(t =>
    (t.symbol ?? '').toString().trim().toUpperCase() === target
  );
}

// 1B) Filtro por HORA (usa tus variables hourFrom/hourTo)
const fromMin = timeToMinutes(document.getElementById('timeFrom')?.value || '00:00');
const toMin   = timeToMinutes(document.getElementById('timeTo')?.value || '23:59');

filteredTrades = filteredTrades.filter(t => {
  const m = getTradeMinutes(t);
  if (m === null) return false;
  return m >= fromMin && m <= toMin;
});
// 1C) Filtro por DÍA DE LA SEMANA (Lunes–Viernes)
const dayEl = document.getElementById('dayFilter');
if (dayEl && dayEl.value !== 'ALL') {
  const targetDay = Number(dayEl.value); // 1 = Lunes ... 5 = Viernes

  filteredTrades = filteredTrades.filter(t => {
    const d = parseDate(t.date);
    if (!d) return false;

    const jsDay = d.getDay(); // 0 = Domingo, 1 = Lunes ... 6 = Sábado
    return jsDay === targetDay;
  });
}
// 1D) Filtro por CONFLUENCIAS (acumulativo)
const selectedConfs = getSelectedConfluences();

if (selectedConfs.length > 0) {
  filteredTrades = filteredTrades.filter(t => {
    const raw = String(t.confluences || '').trim();
    if (!raw) return false;

    const tradeConfs = raw.split(/,|;/).map(x => x.trim()).filter(Boolean);
    return selectedConfs.every(c => tradeConfs.includes(c));
  });
}
// ✅ AHORA SÍ: guardar y mostrar lo que quedó tras TODOS los filtros
FILTERED_TRADES = filteredTrades;

const TRADE_ROWS = filteredTrades.filter(isRealTradeRow);
const kpiTrades = document.getElementById('kpiTrades');
if (kpiTrades) kpiTrades.textContent = String(TRADE_ROWS.length);
 // KPI: TP Óptimo (máx. expectancia) en pips
try {
const res = computeTPOptimoMaxExpectancia(filteredTrades);
  const el = document.getElementById('kpiTPOptimo');
  if (el) el.textContent = (res && Number.isFinite(res.tp)) ? String(Math.round(res.tp)) : '0';
} catch (err) {
  console.error('Error TP Óptimo:', err);
}

// KPI: TP Óptimo (con parciales) en R
try {
const resParcial = computeTPOptimoConParciales(filteredTrades);
  const elParcial = document.getElementById('kpiTPOptimoParcial');
  if (elParcial) {
    elParcial.textContent =
      (resParcial && Number.isFinite(resParcial.tpR))
        ? (resParcial.tpR.toFixed(1) + 'R')
        : '0R';
  }
} catch (err) {
  console.error('Error TP Óptimo (con parciales):', err);
  const elParcial = document.getElementById('kpiTPOptimoParcial');
  if (elParcial) elParcial.textContent = '0R';
}
// KPI: TP Óptimo (con parciales) convertido a PIPS (usando mediana de SL)
try {
  const resParcial = computeTPOptimoConParciales(filteredTrades);

  const slList = (filteredTrades || [])
    .map(t => Number(t.sl_pips))
    .filter(v => Number.isFinite(v) && v > 0);

  const slMed = median(slList); // SL representativo del periodo
  const tpPips = (resParcial && Number.isFinite(resParcial.tpR) && slMed > 0)
    ? (resParcial.tpR * slMed)
    : 0;

  const el = document.getElementById('kpiTPOptimoParcialPips');
  if (el) el.textContent = tpPips ? String(Math.round(tpPips)) : '0';
} catch (err) {
  console.error('Error TP Óptimo (parciales) pips:', err);
  const el = document.getElementById('kpiTPOptimoParcialPips');
  if (el) el.textContent = '0';
}
      // Hide reset button if not in group filter mode
      const resetBtn = $('resetGroupBtn');
      if (resetBtn && !groupFilterActive) {
        resetBtn.style.display = 'none';
      }
const metrics = computeMetrics(filteredTrades);
// Return (%) — compuesto por trade usando el BALANCE ANTERIOR a cada trade.
// Esto NO se distorsiona con depósitos/retiros (cashflows).
{
  // Ordenamos por fecha/hora por seguridad
const sorted = filteredTrades
    .slice()
    .sort((a, b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0));

  let prevBalance = null;     // balance DESPUÉS del evento anterior
  let compounded = 1;         // producto de (1 + r_i)

  for (const t of sorted) {
    const balAfter = (t.balance !== null && t.balance !== undefined) ? Number(t.balance) : null;
    const pnl = Number(t.pnl) || 0;
    const cf  = Number(t.cashflow) || 0;

    // Si no hay balance válido, no podemos usar esta lógica
    if (balAfter === null || !isFinite(balAfter)) continue;

    // Balance ANTES de este evento:
    // - Si ya tenemos prevBalance, ese es el "antes"
    // - Si es el primer evento, lo inferimos: before = after - pnl - cashflow
    const balBefore = (prevBalance !== null && isFinite(prevBalance))
      ? prevBalance
      : (balAfter - pnl - cf);

    // Si esto es un TRADE (pnl != 0), calculamos rendimiento del trade
    // usando el balance ANTES del trade.
    if (pnl !== 0 && balBefore > 0) {
      const r = pnl / balBefore;     // ejemplo: -5.11 / 1083.50 = -0.0047
      compounded *= (1 + r);
    }

    // Actualizamos prevBalance al balance DESPUÉS de este evento
    prevBalance = balAfter;
  }

  const returnFraction = compounded - 1;
  $('kpiReturn').textContent = pct(returnFraction);
}
      $('kpiTotal').textContent = fmt2(metrics.total);
      $('kpiWin').textContent = pct(metrics.winRate);
      $('kpiDD').textContent = pct(metrics.maxDD);
      $('kpiSharpe').textContent = fmt2(metrics.sharpe);
      $('kpiCalmar').textContent = fmt2(metrics.calmar);
      // Set additional KPIs
      $('kpiExpectancy').textContent = fmt2(metrics.expectancy);

      // Compute Risk:Reward metrics and update KPI cards.  These metrics
      // measure the average RR achieved (real) and the average RR potential
      // offered by the market.  The gap RR metric has been removed.
const rrMetrics = computeRRMetrics(filteredTrades);
      $('kpiRRReal').textContent = (Number(rrMetrics.avgReal).toFixed(2) + 'R');
      $('kpiRRPot').textContent  = (Number(rrMetrics.avgPot).toFixed(2) + 'R');
      // KPI: Pips potencial prom. (promedio de MFE en pips)
try {
  const rows = (filteredTrades || []).filter(isRealTradeRow);

  const mfeList = rows
    .map(t => Number(t.mfe_pips))
    .filter(v => Number.isFinite(v) && v > 0);

  const avg = mfeList.length
    ? mfeList.reduce((a,b) => a + b, 0) / mfeList.length
    : 0;

  const el = document.getElementById('kpiPipsPotProm');
  if (el) el.textContent = avg ? `${avg.toFixed(0)} pips` : '0';
} catch (err) {
  console.error('Error Pips potencial prom.:', err);
  const el = document.getElementById('kpiPipsPotProm');
  if (el) el.textContent = '0';
}
      const sim = simulateStrategies2R(filteredTrades);
console.log("Expectancia Parcial 2R:", sim.parcial.toFixed(3));
console.log("Expectancia Fija 2R:", sim.fija.toFixed(3));
      // Compute MFE statistics (trimmed mean and 80th percentile).  We
      // compute these both on a risk‑adjusted basis (ratio of MFE to
      // stop‑loss size) and on raw pips.  This provides guidance on
      // potential risk:reward tuning and absolute pip performance.
const mfeRatioStats = computeMFEStats(filteredTrades, false);
const mfePipsStats  = computeMFEStats(filteredTrades, true);
      if ($('kpiMFEAvg80')) {
        // Display ratio statistics in the "MFE promedio 80%" card.  Two
        // decimal places are shown for RR values.
        $('kpiMFEAvg80').textContent = Number(mfeRatioStats.avg80).toFixed(2);
      }
      if ($('kpiMFEP80')) {
        // Display ratio percentile as the ideal TP in RR terms.
        $('kpiMFEP80').textContent  = Number(mfeRatioStats.p80).toFixed(2);
      }
      if ($('kpiMFEAvg80Pips')) {
        // Show the same statistics in pips.  We round to whole pips for clarity.
        $('kpiMFEAvg80Pips').textContent  = Number(mfePipsStats.avg80).toFixed(0);
      }
      if ($('kpiMFEP80Pips')) {
        $('kpiMFEP80Pips').textContent = Number(mfePipsStats.p80).toFixed(0);
      }
updateEquityChart(metrics);
updatePnlChart(filteredTrades);
renderTable(TRADE_ROWS);
// ===== Comparación TP fijo vs Parciales (2R a 5R) =====
try {
  const key = `${TRADE_ROWS.length}|${TRADE_ROWS[0]?.date || ''}|${TRADE_ROWS[TRADE_ROWS.length-1]?.date || ''}`;

  if (window.__lastCompareKey !== key) {
    window.__lastCompareKey = key;

    const rows = compareStrategies_R(TRADE_ROWS, 2, 5, 0.5);
    console.groupCollapsed('Comparación estrategias (2R → 5R)');
    console.table(rows);
    console.groupEnd();
  }
} catch (e) {
  console.warn('No se pudo comparar estrategias:', e);
}
    }
function updateEquityChart(metricsOrEqSeries) {
  const metrics = (metricsOrEqSeries && metricsOrEqSeries.eqSeries) ? metricsOrEqSeries : null;
  const eqSeries = metrics ? (metrics.eqSeries || []) : (Array.isArray(metricsOrEqSeries) ? metricsOrEqSeries : []);

  const labels = eqSeries.map(p => p.date);

  const hasBalance = eqSeries.some(p => p.balance !== null && p.balance !== undefined && !isNaN(Number(p.balance)));

  const equityMoney = eqSeries.map(p => {
    if (hasBalance) return Number(p.balance) || 0;
    return (accountSize || 0) + (Number(p.equity) || 0);
  });

  let data;
  if (equityType === 'percentage') {
    const twrSeries = metrics && Array.isArray(metrics.twrSeries) ? metrics.twrSeries : [];
    if (hasBalance && twrSeries.length) {
      data = twrSeries.map(p => (p.idx - 1) * 100);
    } else {
      const base = equityMoney[0] || 1;
      data = equityMoney.map(v => base ? ((v / base) - 1) * 100 : 0);
    }
  } else {
    data = equityMoney;
  }

  const mainLabel = equityType === 'percentage' ? 'Equity (%)' : 'Equity ($)';

  const datasets = [{
    label: mainLabel,
    data,
    fill: true,
    borderColor: 'rgb(59,130,246)',
    backgroundColor: 'rgba(59,130,246,0.3)',
    pointRadius: 0,
    tension: 0.3,
    borderWidth: 2
  }];

  if (equityChart) equityChart.destroy();
  equityChart = new Chart($("equityChart"), {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false, axis: 'x' },
      plugins: {
        legend: { display: datasets.length > 1 },
        tooltip: {
          mode: 'index',
          intersect: false,
          callbacks: {
            label: function(ctx) {
              const v = Number(ctx.raw) || 0;
              return equityType === 'percentage'
                ? `${ctx.dataset.label}: ${v.toFixed(2)}%`
                : `${ctx.dataset.label}: ${v.toFixed(2)}`;
            }
          }
        }
      },
      scales: {
        x: {
          ticks: {
            color: '#94a3b8',
            callback: function(value, index) {
              const lab = labels[index];
              return formatDateLabel(lab);
            }
          },
          grid: { color: 'rgba(255,255,255,0.05)' }
        },
        y: {
          ticks: {
            color: '#94a3b8',
            callback: function(value) {
              return equityType === 'percentage'
                ? Number(value).toFixed(2) + '%'
                : Number(value).toFixed(2);
            }
          },
          grid: { color: 'rgba(255,255,255,0.05)' }
        }
      }
    }
  });
}
    function updatePnlChart(trades) {
  // Construimos retornos por periodo usando TWR si hay balance.
  const m = computeMetrics(trades);
  const hasTWR = m.twrSeries && m.twrSeries.length;

  let label;
  if (pnlRange === 'daily') label = 'Retorno diario (%)';
  else if (pnlRange === 'weekly') label = 'Retorno semanal (%)';
  else label = 'Retorno mensual (%)';

  let labels = [];
  let data = [];

// Retorno por periodo usando la MISMA lógica del KPI:
// retorno compuesto por trade = pnl / balance_antes_del_trade
{
  const sorted = (trades || [])
    .slice()
    .filter(t => t.balance !== null && t.balance !== undefined && isFinite(Number(t.balance)))
    .sort((a, b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0));

  const keyFn =
    (pnlRange === 'daily')  ? (d => dayKey(d)) :
    (pnlRange === 'weekly') ? (d => weekKey(d)) :
                              (d => monthKey(d));

  labels = [];
  data = [];

  let prevBalance = null;   // balance DESPUÉS del evento anterior
  let curKey = null;
  let compounded = 1;

  function closePeriod(k, comp) {
    labels.push(k);
    data.push((comp - 1) * 100);
  }

  for (let i = 0; i < sorted.length; i++) {
    const t = sorted[i];
    const d = parseDate(t.date);
    if (!d) continue;

    const k = keyFn(d);

    const balAfter = Number(t.balance);
    const pnl = Number(t.pnl) || 0;
    const cf  = Number(t.cashflow) || 0;

    // Si cambia de periodo, cerramos el anterior
    if (curKey === null) {
      curKey = k;
      compounded = 1;
    } else if (k !== curKey) {
      closePeriod(curKey, compounded);
      curKey = k;
      compounded = 1;
    }

    // Balance ANTES del evento
    const balBefore =
      (prevBalance !== null && isFinite(prevBalance))
        ? prevBalance
        : (balAfter - pnl - cf);

    // Solo compone cuando es TRADE (pnl != 0)
    if (pnl !== 0 && balBefore > 0) {
      const r = pnl / balBefore;
      compounded *= (1 + r);
    }

    // Actualiza prevBalance
    prevBalance = balAfter;
  }

  // Cerrar último periodo
  if (curKey !== null) {
    closePeriod(curKey, compounded);
  }

  // Si no hubo datos, fallback simple
  if (!labels.length) {
    let groups;
    if (pnlRange === 'daily') groups = groupBy(trades, dayKey);
    else if (pnlRange === 'weekly') groups = groupBy(trades, weekKey);
    else groups = groupBy(trades, monthKey);

    labels = groups.map(([k]) => k);
    const startCapital = accountSize || 1;
    data = groups.map(([k, sumPnL]) =>
      startCapital !== 0 ? (sumPnL / startCapital) * 100 : 0
    );
  }
}

  if (pnlChart) pnlChart.destroy();
  pnlChart = new Chart($("pnlChart"), {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: label,
        data: data,
        backgroundColor: 'rgba(59,130,246,0.5)',
        borderColor: 'rgb(59,130,246)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false, axis: 'x' },
      plugins: {
        legend: { display: false },
        tooltip: {
          mode: 'index',
          intersect: false,
          callbacks: {
            label: function(ctx) {
              const v = Number(ctx.raw) || 0;
              return `${ctx.dataset.label}: ${v.toFixed(2)}%`;
            }
          }
        }
      },
      scales: {
        x: {
          ticks: {
            color: '#94a3b8',
            maxRotation: 75,
            minRotation: 30,
            callback: function(value, index) {
              const lab = labels[index];
              return formatDateLabel(lab);
            }
          },
          grid: { color: 'rgba(255,255,255,0.05)' }
        },
        y: {
          ticks: {
            color: '#94a3b8',
            callback: function(value) {
              return Number(value).toFixed(2) + '%';
            }
          },
          grid: { color: 'rgba(255,255,255,0.05)' }
        }
      },
      onClick: (event, elements) => {
        if (elements.length) {
          const index = elements[0].index;
          const key = labels[index];
          filterTradesByGroup(key);
        }
      }
    }
  });
}

    // Render table rows
    function renderTable(trades) {
        trades = (trades || []).filter(isRealTradeRow);
      const tbody = $('tradesBody');
      const search = $('searchInput').value.toLowerCase().trim();
      const filtered = !search ? trades : trades.filter(t => {
        return (t.symbol && t.symbol.toLowerCase().includes(search)) ||
               (t.type && t.type.toLowerCase().includes(search)) ||
               (t.comment && t.comment.toLowerCase().includes(search)) ||
               (t.date && t.date.toLowerCase().includes(search));
      });
      $('tradeStats').textContent = `${filtered.length} trade${filtered.length === 1 ? '' : 's'}`;
      tbody.innerHTML = '';
      filtered.sort((a,b) => (parseDate(a.date) ?? 0) - (parseDate(b.date) ?? 0)).forEach(t => {
        const tr = document.createElement('tr');
        const cls = t.pnl >= 0 ? 'pos' : 'neg';
const outcome = (t.outcome || '').toUpperCase();
const outcomeClass =
  outcome === 'WIN'  ? 'outcome-win'  :
  outcome === 'LOSS' ? 'outcome-loss' :
  outcome === 'BE'   ? 'outcome-be'   : '';

tr.innerHTML = `
  <td class="mono col-date">${formatPrettyDate(t.date, true)}</td>
  <td>${t.symbol || '-'}</td>
  <td>${t.type || '-'}</td>
  <td class="mono">${(t.entry !== undefined && t.entry !== null && String(t.entry).trim() !== '') ? t.entry : '-'}</td>
  <td class="${outcomeClass}">${outcome || '-'}</td>
  <td class="mono ${cls}">${fmt2(t.pnl)}</td>
  <td>${t.comment || ''}</td>
`;        tr.addEventListener('click', () => showTradeDetails(t));
        tbody.appendChild(tr);
      });
    }
    // ===== Lightbox para ampliar imágenes =====
function openLightbox(src) {
  const lb = document.getElementById('imgLightbox');
  const im = document.getElementById('imgLightboxImg');
  if (!lb || !im) return;

  im.src = src;
  lb.style.display = 'flex';
  document.body.style.overflow = 'hidden';
}

function closeLightbox() {
  const lb = document.getElementById('imgLightbox');
  const im = document.getElementById('imgLightboxImg');
  if (!lb || !im) return;

  lb.style.display = 'none';
  im.src = '';
  document.body.style.overflow = '';
}

(function initLightbox() {
  const lb = document.getElementById('imgLightbox');
  const closeBtn = document.getElementById('imgLightboxClose');
  const img = document.getElementById('imgLightboxImg');

if (closeBtn) {
  closeBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    closeLightbox();
  });
}
  if (lb) {
    lb.addEventListener('click', (e) => {
      if (e.target === lb) closeLightbox();
    });
  }

  if (img) img.addEventListener('click', (e) => e.stopPropagation());

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeLightbox();
  });
})();
    // Show trade detail modal
    function showTradeDetails(trade) {
      const modal = $('detailModal');
      const grid = $('detailGrid');
      const images = $('detailImages');
      grid.innerHTML = '';
      images.innerHTML = '';
      const detailPairs = [
        { label: 'Fecha', value: formatPrettyDate(trade.date, true) },
        { label: 'Símbolo', value: trade.symbol },
        { label: 'Tipo', value: trade.type },
        { label: 'Timeframe', value: trade.tf },
      // Format numeric values to two decimals where possible
      { label: 'Entrada', value: isNaN(Number(trade.entry)) ? trade.entry : fmt2(Number(trade.entry)) },
      { label: 'Stop', value: isNaN(Number(trade.sl)) ? trade.sl : fmt2(Number(trade.sl)) },
{ label: 'TP1 (pips)', value: (trade.tp1_pips ?? '-') },
{ label: 'TP2 (pips)', value: (trade.tp2_pips ?? '-') },        { label: 'PnL', value: fmt2(trade.pnl) },
        { label: 'Setup', value: trade.setup },
        { label: 'Confluencias', value: trade.confluences },
        { label: 'Comentario', value: trade.comment }
      ];
      detailPairs.forEach(item => {
        const div = document.createElement('div');
        div.innerHTML = `<span>${item.label}</span><strong>${item.value || '-'}</strong>`;
        grid.appendChild(div);
      });
// ===== Mostrar captura(s) y permitir zoom en la misma página =====
function tradingViewToImageUrl(u) {
  const m = String(u).match(/tradingview\.com\/x\/([A-Za-z0-9]+)\//i);
  if (!m) return null;

  const id = m[1];
  const folder = id[0].toLowerCase();
  return `https://s3.tradingview.com/snapshots/${folder}/${id}.png`;
}

// ===== Mostrar captura(s) y permitir zoom en la misma página =====
if (trade.image) {
  const urls = trade.image
  // separa por " | " o ";" o saltos de línea
  .split(/\s*\|\s*|;|\n+/)
  .map(u => u.trim())
  .filter(Boolean);

  urls.forEach(u => {
    const img = document.createElement('img');

    const directImg = tradingViewToImageUrl(u);
    const srcToUse = directImg || u;

    img.src = srcToUse;
    img.alt = 'captura de trade';
    img.loading = 'lazy';

    img.style.maxWidth = '100%';
    img.style.borderRadius = '0.4rem';
    img.style.border = '1px solid var(--border)';
    img.style.cursor = 'zoom-in';

    img.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      openLightbox(srcToUse);
    });

    img.onerror = () => {
      img.style.display = 'none';
      console.warn('No se pudo cargar la captura:', u);
    };

    images.appendChild(img);
  });
}
      modal.style.display = 'flex';
    }
    $('closeModalBtn').addEventListener('click', () => {
      $('detailModal').style.display = 'none';
    });
    // Search bar filtering
    $('searchInput').addEventListener('input', () => {
      renderTable(FILTERED_TRADES);
    });
    // Range filters
    // Define rangeButtons on the outer scope so it is always available when applyCurrentFilters runs.
    // We assign here instead of using const declaration to avoid temporal dead‑zone issues.
    rangeButtons = ['todayBtn','weekBtn','monthBtn','ytdBtn','customBtn'];
    rangeButtons.forEach(id => {
      $(id).addEventListener('click', () => {
        rangeButtons.forEach(btnId => $(btnId).classList.remove('active'));
        $(id).classList.add('active');
        if (id === 'customBtn') {
  $('customRange').style.display = 'flex';
  // ✅ si ya hay fechas elegidas, aplica en caliente
  const s = $('startDate').value;
  const e = $('endDate').value;
  if (s && e) applyCurrentFilters();
} else {
  $('customRange').style.display = 'none';
  applyRangePreset(id);
}
      });
    });

    // Toggle PnL chart range
    Array.from($('pnlToggle').children).forEach(btn => {
      btn.addEventListener('click', () => {
        Array.from($('pnlToggle').children).forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        pnlRange = btn.getAttribute('data-range');
        updatePnlChart(FILTERED_TRADES);
      });
    });

    // Reset group filter button
function setActiveRangeButton(idOrNull) {
  const btnIds = ['todayBtn','weekBtn','monthBtn','ytdBtn','customBtn'];
  btnIds.forEach(id => {
    const b = document.getElementById(id);
    if (b) b.classList.toggle('active', idOrNull === id);
  });
}

const resetFiltersBtn = document.getElementById('resetFiltersBtn');
if (resetFiltersBtn) {
  resetFiltersBtn.addEventListener('click', () => {
    // Par
    const pf = document.getElementById('pairFilter');
    if (pf) pf.value = 'ALL';

    // Hora
    const hf = document.getElementById('timeFrom');
    const ht = document.getElementById('timeTo');
    if (hf) hf.value = '00:00';
    if (ht) ht.value = '23:59';

    CONF_SELECTED.clear();
updateConfButtonLabel();
renderConfluenceDropdown('');
const cs = document.getElementById('confSearch');
if (cs) cs.value = '';

    // Custom range
    const cr = document.getElementById('customRange');
    if (cr) cr.style.display = 'none';
    const s = document.getElementById('startDate');
    const e = document.getElementById('endDate');
    if (s) s.value = '';
    if (e) e.value = '';

    // Día
const df = document.getElementById('dayFilter');
if (df) df.value = 'ALL';

    // Quitar rango activo (histórico completo)
    setActiveRangeButton(null);
const si = document.getElementById('searchInput');
if (si) si.value = '';
    // Render histórico completo
    renderAll(ALL_TRADES);
  });
}
// ===== Reset group filter (Ver todo) =====
const resetGroupBtn = document.getElementById('resetGroupBtn');

if (resetGroupBtn) {
  resetGroupBtn.addEventListener('click', () => {
    groupFilterActive = false;
    resetGroupBtn.style.display = 'none';

    // Volver a aplicar los filtros normales (fecha / hora / par)
    applyCurrentFilters();
  });
}
    // Apply range preset logic
    function applyRangePreset(id) {
      if (!ALL_TRADES.length) { FILTERED_TRADES = []; renderAll(ALL_TRADES); return; }
      const now = new Date();
      let startDate, endDate;
      switch(id) {
        case 'todayBtn':
          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          endDate   = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
          break;
        case 'weekBtn':
          const day = now.getDay() || 7;
          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - day + 1);
          endDate   = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
          break;
          case 'monthBtn':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          endDate   = new Date(now.getFullYear(), now.getMonth()+1, 1);
          break;
        case 'ytdBtn':
          startDate = new Date(now.getFullYear(), 0, 1);
          endDate   = new Date(now.getFullYear()+1, 0, 1);
          break;
        default:
          startDate = null;
          endDate   = null;
      }
      if (startDate && endDate) {
        applyRangeDates(startDate, endDate);
      }
    }
    // Custom range
    function applyRangeCustom(start, end) {
      const s = new Date(start);
      const e = new Date(end);
      e.setDate(e.getDate() + 1);
      applyRangeDates(s, e);
    }
    function applyRangeDates(s, e) {
      const filtered = ALL_TRADES.filter(t => {
        const d = parseDate(t.date);
        return d && d >= s && d < e;
      });
      renderAll(filtered);
    }
    // Reapply current filters when new data loaded
    function applyCurrentFilters() {
  groupFilterActive = false;
  const resetBtn = $('resetGroupBtn');
  if (resetBtn) resetBtn.style.display = 'none';

  if (!Array.isArray(rangeButtons) || rangeButtons.length === 0) {
    rangeButtons = ['todayBtn','weekBtn','monthBtn','ytdBtn','customBtn'];
  }

  const active = rangeButtons.find(id => $(id).classList.contains('active'));
  if (active) {
    if (active === 'customBtn') {
      const s = $('startDate').value;
      const e = $('endDate').value;
      if (s && e) {
        applyRangeCustom(s, e);
      } else {
        renderAll(ALL_TRADES);
      }
    } else {
      applyRangePreset(active);
    }
  } else {
    renderAll(ALL_TRADES);
  }
}

/* 👇👇👇 PEGA AQUÍ, JUSTO AQUÍ 👇👇👇 */

// ===== Auto-aplicar filtros (sin botón) =====
function wireAutoFilters() {
  const pairEl = document.getElementById('pairFilter');
  const dayEl  = document.getElementById('dayFilter');
  const tFrom  = document.getElementById('timeFrom');
  const tTo    = document.getElementById('timeTo');
  const sDate  = document.getElementById('startDate');
  const eDate  = document.getElementById('endDate');

  if (pairEl) pairEl.addEventListener('change', applyCurrentFilters);
  if (dayEl)  dayEl.addEventListener('change', applyCurrentFilters);

  if (tFrom) {
    tFrom.addEventListener('change', applyCurrentFilters);
    tFrom.addEventListener('input', applyCurrentFilters);
  }
  if (tTo) {
    tTo.addEventListener('change', applyCurrentFilters);
    tTo.addEventListener('input', applyCurrentFilters);
  }

  function maybeApplyCustomRange() {
    const customBtn = document.getElementById('customBtn');
    if (customBtn && customBtn.classList.contains('active')) {
      applyCurrentFilters();
    }
  }

  if (sDate) {
    sDate.addEventListener('change', maybeApplyCustomRange);
    sDate.addEventListener('input', maybeApplyCustomRange);
  }
  if (eDate) {
    eDate.addEventListener('change', maybeApplyCustomRange);
    eDate.addEventListener('input', maybeApplyCustomRange);
  }
}
(function wireConfDropdown(){
  const root = document.getElementById('confMulti');
  const btn  = document.getElementById('confBtn');
  const panel= document.getElementById('confPanel');
  const s    = document.getElementById('confSearch');
  const all  = document.getElementById('confAll');
  const none = document.getElementById('confNone');

  if (!root || !btn || !panel) return;

  btn.addEventListener('click', (e) => {
    e.preventDefault();
    root.classList.toggle('open');
    if (root.classList.contains('open')) {
      setTimeout(() => s && s.focus(), 0);
    }
  });

  document.addEventListener('click', (e) => {
    if (!root.contains(e.target)) root.classList.remove('open');
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') root.classList.remove('open');
  });

  if (s) {
    s.addEventListener('input', () => {
      renderConfluenceDropdown(s.value);
    });
  }

  if (all) all.addEventListener('click', () => {
    CONF_SELECTED = new Set(CONF_OPTIONS);
    updateConfButtonLabel();
    renderConfluenceDropdown(s ? s.value : '');
    applyCurrentFilters();
  });

  if (none) none.addEventListener('click', () => {
    CONF_SELECTED.clear();
    updateConfButtonLabel();
    renderConfluenceDropdown(s ? s.value : '');
    applyCurrentFilters();
  });
})();
// Ejecutar una sola vez
wireAutoFilters();

    // Filter trades by group label from PnL chart click
   function filterTradesByGroup(key) {
  let startDate, endDate;

  if (pnlRange === 'daily') {
    startDate = new Date(key);
    endDate = new Date(key);
    endDate.setDate(endDate.getDate() + 1);
  } else if (pnlRange === 'weekly') {
    const parts = key.split('-W');
    const year = parseInt(parts[0], 10);
    const week = parseInt(parts[1], 10);
    const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
    const dow = simple.getUTCDay() || 7;
    startDate = new Date(simple);
    startDate.setUTCDate(simple.getUTCDate() - (dow - 1));
    endDate = new Date(startDate);
    endDate.setUTCDate(startDate.getUTCDate() + 7);
  } else {
    const parts = key.split('-');
    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10) - 1;
    startDate = new Date(year, month, 1);
    endDate = new Date(year, month + 1, 1);
  }

  // ✅ marca ANTES de renderizar
  groupFilterActive = true;

  applyRangeDates(startDate, endDate);

  const resetBtn = $('resetGroupBtn');
  if (resetBtn) resetBtn.style.display = 'inline-block';
}
    // Initial demo load for quick preview
    // Uncomment to load demo automatically
    // $('demoBtn').click();

    // ==== Google Sheet auto‑loading functions ====
    // These helpers allow the journal to sync with a public Google Sheet
    // published as CSV.  Set SHEET_CSV_URL to your sheet's CSV link and
    // call startAutoRefresh() to begin polling.
    let SHEET_CSV_URL = '';
    let SHEET_TIMER   = null;

    async function loadFromGoogleSheet(url) {
      if (!url) return;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
          console.error('No se pudo leer el CSV del Sheet');
          return;
        }
        const csv = await res.text();
        const parsed = Papa.parse(csv, { header: true, skipEmptyLines: true });
        // Clean rows: remove accidental header row if the sheet contains a blank first line
        const rawRows = (parsed.data || []);
        const cleaned = rawRows.filter(row => {
          // Skip if the date field literally equals 'Date' (indicating header)
          if (row.date === 'Date' || row.Date === 'Date') return false;
          // Skip completely empty rows
          const keys = Object.keys(row);
          const allEmpty = keys.length === 0 || keys.every(k => String(row[k] ?? '').trim() === '');
          return !allEmpty;
        });
        const trades = cleaned
          .map(normalize)
.filter(t => {
  const d = parseDate(t.date);
  return d && !isNaN(d.getTime()) && Number.isFinite(t.pnl);
});        // Replace global trades and update UI
        ALL_TRADES = trades;
        populatePairFilter(ALL_TRADES);
        populateConfluenceFilter(ALL_TRADES);
        applyCurrentFilters();
        // Update last update time
        const now = new Date();
        const elem = document.getElementById('lastUpdated');
        if (elem) {
          const time = now.toLocaleString('es-MX', { hour12: false });
          elem.textContent = 'Última actualización: ' + time;
        }
      } catch(err) {
        console.error(err);
      }
    }

    function startAutoRefresh(url, seconds = 60) {
      SHEET_CSV_URL = url;
      // Clear existing interval if present
      if (SHEET_TIMER) clearInterval(SHEET_TIMER);
      // Perform initial load
      loadFromGoogleSheet(url);
      // Set up periodic refresh
      SHEET_TIMER = setInterval(() => {
        loadFromGoogleSheet(SHEET_CSV_URL);
      }, seconds * 1000);
    }

    // Start syncing with the user's provided Sheet.
    startAutoRefresh('https://docs.google.com/spreadsheets/d/e/2PACX-1vQCpyYDfCdQ7uwupJfK7VKqZU2tiruPfGC0o1yL3o-BzI1GEfJs2ZJ-4dQiIWe67Xy3vjrzPfRO9pFz/pub?gid=0&single=true&output=csv', 60);
  let simChart = null;
function startAutoRefreshPropFirms(url, seconds = 60) {
  async function loadPF() {
    try {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) return;

      const csv = await res.text();
      const parsed = Papa.parse(csv, { header: true, skipEmptyLines: true });

      const rawRows = (parsed.data || []);
      const cleaned = rawRows.filter(row => {
        const keys = Object.keys(row);
        const allEmpty = keys.length === 0 || keys.every(k => String(row[k] ?? '').trim() === '');
        return !allEmpty;
      });

      const rows = cleaned
        .map(normalizePropFirm)
        .filter(r => {
          const d = parseDate(r.date);
          return d && !isNaN(d.getTime());
        });

      PF_ROWS = rows;
      renderPropFirmDashboard(PF_ROWS);

    } catch (e) {
      console.error('Prop Firms load error:', e);
    }
  }

  if (PF_TIMER) clearInterval(PF_TIMER);

  loadPF();
  PF_TIMER = setInterval(loadPF, seconds * 1000);
}

startAutoRefreshPropFirms(
  'https://docs.google.com/spreadsheets/d/e/2PACX-1vQCpyYDfCdQ7uwupJfK7VKqZU2tiruPfGC0o1yL3o-BzI1GEfJs2ZJ-4dQiIWe67Xy3vjrzPfRO9pFz/pub?gid=1561874690&single=true&output=csv',
  60
);
function renderSimTable(rows) {
  const tb = document.getElementById('simTableBody');
  if (!tb) return;

  tb.innerHTML = '';
  rows.forEach(r => {
    const tr = document.createElement('tr');
    const cls = (r.Delta_Fija_Menos_Parcial >= 0) ? 'pos' : 'neg';

    tr.innerHTML = `
      <td class="mono">${r.TP_R.toFixed(2)}</td>
      <td class="mono">${r.Exp_Fija_R.toFixed(3)}</td>
      <td class="mono">${(r.WR_Fija * 100).toFixed(1)}%</td>
      <td class="mono">${r.Exp_Parcial_R.toFixed(3)}</td>
      <td class="mono">${(r.WR_Parcial * 100).toFixed(1)}%</td>
      <td class="mono ${cls}">${r.Delta_Fija_Menos_Parcial.toFixed(3)}</td>
      <td class="mono">${r.N}</td>
    `;
    tb.appendChild(tr);
  });
}

function renderSimChart(rows) {
  const el = document.getElementById('simChart');
  if (!el) return;

  const labels = rows.map(r => r.TP_R.toFixed(2));
  const fixed  = rows.map(r => r.Exp_Fija_R);
  const part   = rows.map(r => r.Exp_Parcial_R);

  if (simChart) simChart.destroy();

  simChart = new Chart(el, {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label: 'Expectancia TP fijo (R)',
          data: fixed,
          tension: 0.25,
          borderWidth: 2,
          pointRadius: 0
        },
        {
          label: 'Expectancia Parciales (R)',
          data: part,
          tension: 0.25,
          borderWidth: 2,
          pointRadius: 0
        }
      ]
    },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { labels: { color: '#94a3b8' } },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${Number(ctx.raw).toFixed(3)}R`
          }
        }
      },
      scales: {
        x: {
          ticks: { color: '#94a3b8', maxRotation: 0, autoSkip: true },
          grid: { color: 'rgba(255,255,255,0.05)' }
        },
        y: {
          ticks: { color: '#94a3b8' },
          grid: { color: 'rgba(255,255,255,0.05)' }
        }
      }
    }
  });
}

function runTPSimulation() {
  // IMPORTANT: usamos SOLO trades reales (no cashflows)
  const trades = (FILTERED_TRADES || []).filter(isRealTradeRow);

  // Necesitamos SL y MFE para simular
  const valid = trades.filter(t =>
    Number.isFinite(Number(t.sl_pips)) && Number(t.sl_pips) > 0 &&
    Number.isFinite(Number(t.mfe_pips)) && Number(t.mfe_pips) >= 0
  );

  const rMin = Number(document.getElementById('simRMin')?.value || 1);
  const rMax = Number(document.getElementById('simRMax')?.value || 6);
  const step = Number(document.getElementById('simStep')?.value || 0.5);

  if (!valid.length) {
    renderSimTable([]);
    if (simChart) simChart.destroy();
    console.warn('No hay trades con SL y MFE válidos para simular.');
    return;
  }

  // Usa tu función (ya la tienes)
  const rows = compareStrategies_R(valid, rMin, rMax, step);

  renderSimChart(rows);
  renderSimTable(rows);

  // Bonus: imprimir mejor TP sugerido para cada estrategia
  const bestFixed = rows.reduce((best, r) => (r.Exp_Fija_R > best.Exp_Fija_R ? r : best), rows[0]);
  const bestPart  = rows.reduce((best, r) => (r.Exp_Parcial_R > best.Exp_Parcial_R ? r : best), rows[0]);

  console.log('Mejor TP fijo:', bestFixed);
  console.log('Mejor TP parciales:', bestPart);
}

// Botón
const runSimBtn = document.getElementById('runSimBtn');
if (runSimBtn) runSimBtn.addEventListener('click', runTPSimulation);

// Para que se actualice solo cuando cambias filtros (opcional):
// Llama runTPSimulation() al final de renderAll()
  </script>
</body>
</html>